C51 COMPILER V9.59.0.0   FS                                                                01/19/2019 20:05:14 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE FS
OBJECT MODULE PLACED IN .\Objects\fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE fs.c COMPACT OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\fs.lst) TABS(2) OBJECT(.\Objects\fs.obj)

line level    source

   1          #include "12864.h"
   2          #include "delay.h"
   3          #include "sdcard.h"
   4          #include "num.h"
   5          #include "fs.h"
   6          
   7          #define uchar unsigned char
   8          #define uint unsigned int
   9          #define ulong unsigned long int
  10          
  11          ulong FS_PatternSector;           // ·ÖÇøµØÖ·
  12          uchar FS_SectorPerClust;          // Ã¿´ØÉÈÇøÊý
  13          uint  FS_PersistSector;           // ±£ÁôÉÈÇøÊý
  14          ulong FS_FatUseSector;            // FAT±íÕ¼ÓÃÉÈÇøÊý
  15          ulong FS_FatSector;               // FAT1±íÆðÊ¼ÉÈÇøºÅ
  16          ulong FILE_BadApple_StartClust;   // badapple.binÎÄ¼þÆðÊ¼´ØºÅ
  17          
  18          // ¶ÁÈ¡FAT32ÎÄ¼þÏµÍ³ÐÅÏ¢
  19          void FS_Init() {
  20   1        uint i;
  21   1        uchar *hex;
  22   1        SD_Start();
  23   1        // ¶ÁMBR È¡·ÖÇøµØÖ·
  24   1        if (SD_StartReadBlock(0x00000000)) {
  25   2          for (i = 0; i < 0x01C6; i++)
  26   2            SD_Data_Read();
  27   2          FS_PatternSector = SD_Data_Read();
  28   2          FS_PatternSector |= SD_Data_Read() << 8;
  29   2          FS_PatternSector |= SD_Data_Read() << 16;
  30   2          FS_PatternSector |= SD_Data_Read() << 24;
  31   2          i += 4;
  32   2          while (i++ < 0x202)
  33   2            SD_Data_Read();
  34   2          LCD12864_Positon(1, 0);
  35   2          LCD12864_WriteText("·ÖÇø  0x");
  36   2          hex = ul2hstr(FS_PatternSector);
  37   2          for (i = 0; i < 8; i++)
  38   2            LCD12864_WriteData(*(hex + i));
  39   2        } else {
  40   2          LCD12864_Positon(1, 0);
  41   2          LCD12864_WriteText("·ÖÇøµØÖ·¶ÁÈ¡Ê§°Ü");
  42   2          return;
  43   2        }
  44   1        // ¶ÁDBR È¡Ã¿´ØÉÈÇøÊý ±£ÁôÉÈÇøÊý ±íÕ¼ÓÃÉÈÇøÊý ¸ùÄ¿Â¼´ØºÅ¼ÙÉèÎª2
  45   1        if (SD_StartReadBlock(FS_PatternSector)) {
  46   2          for (i = 0; i < 0x000D; i++)
  47   2            SD_Data_Read();
  48   2          FS_SectorPerClust = SD_Data_Read(); // 0x000D Ã¿´ØÉÈÇøÊý
  49   2          FS_PersistSector = SD_Data_Read(); // 0x0E-0x0F ±£ÁôÉÈÇøÊý
  50   2          FS_PersistSector |= SD_Data_Read() << 8;
  51   2          i += 3;
  52   2          while (i++ < 0x0024)
  53   2            SD_Data_Read();
  54   2          FS_FatUseSector = SD_Data_Read(); // 0x24-0x27 Ã¿¸öFAT±íÕ¼ÓÃÉÈÇøÊý
C51 COMPILER V9.59.0.0   FS                                                                01/19/2019 20:05:14 PAGE 2   

  55   2          FS_FatUseSector |= SD_Data_Read() << 8;
  56   2          FS_FatUseSector |= SD_Data_Read() << 16;
  57   2          FS_FatUseSector |= SD_Data_Read() << 24;
  58   2          i += 4;
  59   2          while (i++ < 0x0202)
  60   2            SD_Data_Read();
  61   2          SD_Stop();
  62   2          LCD12864_Positon(2, 0);
  63   2          LCD12864_WriteText("Ã¿´ØÉÈÇø     ");
  64   2          hex = uc2dstr(FS_SectorPerClust);
  65   2          for (i = 0; i < 3; i++)
  66   2            LCD12864_WriteData(*(hex + i));
  67   2          LCD12864_Positon(3, 0);
  68   2          LCD12864_WriteText("±£ÁôÉÈÇø   ");
  69   2          hex = ui2dstr(FS_PersistSector);
  70   2          for (i = 0; i < 5; i++)
  71   2            LCD12864_WriteData(*(hex + i));
  72   2          delay(3000);
  73   2          LCD12864_Clear();
  74   2          LCD12864_WriteText("FAT Õ¼0x");
  75   2          hex = ul2hstr(FS_FatUseSector);
  76   2          for (i = 0; i < 8; i++)
  77   2            LCD12864_WriteData(*(hex + i));
  78   2        } else {
  79   2          SD_Stop();
  80   2          LCD12864_Positon(2, 0);
  81   2          LCD12864_WriteText("·ÖÇøÐÅÏ¢¶ÁÈ¡Ê§°Ü");
  82   2          return;
  83   2        }
  84   1      }
  85          
  86          // È¡ÏÂÒ»¸ö´Ø(FATÖÐ±¾´ØµÄÊý¾Ý)  0x0FFFFFÊÇ½áÊø
  87          ulong FS_GetNextClust(ulong clust) {
  88   1        ulong sector = FS_FatSector + (clust / 128); // Ò»¸ö´Ø4×Ö½Ú Ò»¸öÉÈÇø´æ128¸ö´Ø
  89   1        uchar pos = clust % 128; // ÉÈÇøÀïµÄµÚ¼¸¸ö×Ö½Ú
  90   1        uchar i;
  91   1        ulong result = 0;
  92   1        if (SD_StartReadBlock(sector)) {
  93   2          for(i = 0; i < 128; i++) {
  94   3            if (i == pos) {
  95   4              result = SD_Data_Read();
  96   4              result |= SD_Data_Read() << 8;
  97   4              result |= SD_Data_Read() << 16;
  98   4              result |= SD_Data_Read() << 24;
  99   4            } else {
 100   4              SD_Data_Read();
 101   4              SD_Data_Read();
 102   4              SD_Data_Read();
 103   4              SD_Data_Read();
 104   4            }
 105   3          }
 106   2          SD_Data_Read();
 107   2          SD_Data_Read();
 108   2        }
 109   1        return result;
 110   1      }
 111          
 112          void FS_FindBadAppleBin() {
 113   1        struct FS_FILE file;
 114   1        ulong nextClust = 2; // Ò»°ãµÄÊÇ2  ²»ÊÇ2µÄ²»ÄÜÓÃ ²»¹ÜÁË
 115   1        ulong rootSector;
 116   1        uchar clustSector, fatItem, j;
C51 COMPILER V9.59.0.0   FS                                                                01/19/2019 20:05:14 PAGE 3   

 117   1        uchar *hex;
 118   1        
 119   1        FS_FatSector = FS_PatternSector + FS_PersistSector; // FAT1±íµÄÉÈÇø = ·ÖÇøDBRÉÈÇø + ±£ÁôÉÈÇøÊý
 120   1        rootSector = FS_FatSector + FS_FatUseSector + FS_FatUseSector; // ¸ù(2´Ø)ÉÈÇø = FAT1ÉÈÇø + FATÕ¼ÓÃÉÈÇøx2
 121   1        FILE_BadApple_StartClust = 0;
 122   1        LCD12864_Positon(1, 0);
 123   1        LCD12864_WriteText("ËÑË÷BADAPPLE.BIN");
 124   1        SD_Start();
 125   1        while (nextClust != 0x0FFFFFFF) { // ±éÀú¸ùÄ¿Â¼ËùÓÐ´Ø
 126   2          for (clustSector = 0; clustSector < FS_SectorPerClust; clustSector++) { // ±éÀú¸ùÄ¿Â¼Ò»¸ö´ØµÄËùÓÐÉÈÇø
 127   3            if (SD_StartReadBlock(rootSector + (((nextClust - 2) * FS_SectorPerClust) + clustSector))) {
 128   4              for (fatItem = 0; fatItem < 16; fatItem++) { // ±éÀú¸ùÄ¿Â¼Ò»¸ö´ØµÄÒ»¸öÉÈÇøµÄÒ»Ïî  Ò»Ïî32×Ö½Ú ¹²16*32=5
             -12×Ö½Ú=1ÉÈÇø
 129   5                for (j = 0; j < 8; j++) // 8×Ö½ÚµÄÎÄ¼þÃû
 130   5                  file.FileName[j] = SD_Data_Read();
 131   5                for (j = 0; j < 3; j++) // 3×Ö½ÚµÄÀ©Õ¹Ãû
 132   5                  file.FileType[j] = SD_Data_Read();
 133   5                file.FileAttribute = SD_Data_Read(); // 1×Ö½ÚµÄÊôÐÔ
 134   5                if (file.FileAttribute != 0x20 || file.FileName[0] == 0xE5) { // ²»ÊÇ¹éµµÎÄ¼þ»òÒÑ±»É¾³ý Ö±½ÓÌø¹ý
 135   6                  for (j = 0; j < 20; j++) // ºó±ßµÄ20×Ö½Ú¶ªÆú
 136   6                    SD_Data_Read();
 137   6                  continue;
 138   6                }
 139   5                for (j = 0; j < 8; j++) // 1×Ö½ÚµÄ±£Áô 1×Ö½ÚµÄ´´½¨Ê±¼äºÁÃë 2×Ö½Ú´´½¨Ê±¼ä 2×Ö½Ú´´½¨ÈÕÆÚ 2×Ö½Ú×îºó¶ÁÈ¡È
             -ÕÆÚ = 8×Ö½Ú¶ªÆú
 140   5                  SD_Data_Read();
 141   5                file.FileClust = SD_Data_Read() << 16; // ÆðÊ¼´Ø¸ß2×Ö½Ú
 142   5                file.FileClust |= SD_Data_Read() << 24;
 143   5                for (j = 0; j < 4; j++) // 2×Ö½ÚÐÞ¸ÄÊ±¼ä 2×Ö½ÚÐÞ¸ÄÈÕÆÚ = 4×Ö½Ú¶ªÆú
 144   5                  SD_Data_Read();
 145   5                file.FileClust |= SD_Data_Read(); // ÆðÊ¼´ØµÍ2×Ö½Ú
 146   5                file.FileClust |= SD_Data_Read() << 8;
 147   5                file.FileLength = SD_Data_Read(); // 4×Ö½ÚµÄÎÄ¼þ³¤¶È
 148   5                file.FileLength |= SD_Data_Read() << 8;
 149   5                file.FileLength |= SD_Data_Read() << 16;
 150   5                file.FileLength |= SD_Data_Read() << 24;
 151   5                if (file.FileName[0] == 'B' && file.FileName[1] == 'A' && file.FileName[2] == 'D' && file.FileName[3]
             - == 'A' && 
 152   5                        file.FileName[4] == 'P' && file.FileName[5] == 'P' && file.FileName[6] == 'L' && file.FileName[7]
             - == 'E' && 
 153   5                        file.FileType[0] == 'B' && file.FileType[1] == 'I' && file.FileType[2] == 'N') {
 154   6                  FILE_BadApple_StartClust = file.FileClust;
 155   6                }
 156   5              }
 157   4              SD_Data_Read();
 158   4              SD_Data_Read();
 159   4              if (FILE_BadApple_StartClust)
 160   4                break;
 161   4            }
 162   3          }
 163   2          if (FILE_BadApple_StartClust)
 164   2            break;
 165   2          nextClust = FS_GetNextClust(nextClust);
 166   2        }
 167   1        if (FILE_BadApple_StartClust) {
 168   2          LCD12864_Positon(2, 0);
 169   2          LCD12864_WriteText("ÕÒµ½  0x");
 170   2          hex = ul2hstr(FILE_BadApple_StartClust);
 171   2          for (j = 0; j < 8; j++)
 172   2            LCD12864_WriteData(*(hex + j));
 173   2        } else {
 174   2          LCD12864_Positon(2, 0);
C51 COMPILER V9.59.0.0   FS                                                                01/19/2019 20:05:14 PAGE 4   

 175   2          LCD12864_WriteText("ÎÄ¼þÎ´ÕÒµ½");
 176   2        }
 177   1        SD_Stop();
 178   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2649    ----
   CONSTANT SIZE    =    115    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     19      53
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
